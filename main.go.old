package main

import(
	"fmt"
	"strconv"
)

type term struct {
	negate	bool
	label	string
	idx		int
}

func ( t term ) String() string {
	out := ""
	if t.negate {
		out += "~"
	} else {
		out += " "
	}

	out += fmt.Sprintf( "%s%d", t.label, t.idx )
	return out
}

// Use kclauses to go from graph to SAT
type kClause struct {
	terms	[]term
}

func genKClause( adj [][]bool, i int )( kClause, kClause ){
	var kc kClause
	var kn kClause

	for j := range adj[ i ] {
		if j == i {
			continue
		}
		var t term

		t.negate = !adj[ i ][ j ]
		t.label = ""
		t.idx = j

		if adj[ i ][ j ] {
			kc.terms = append( kc.terms, t )
		} else {
			kn.terms = append( kn.terms, t )
		}
	}

	return kc, kn
}

func ( k kClause ) String() string {
	if len( k.terms ) == 0 {
		return ""
	}

	if len( k.terms ) == 1 {
		return fmt.Sprintf( "( %s )", k.terms[ 0 ])
	}

	if len( k.terms ) == 2 {
		return fmt.Sprintf( "( %s v %s )", k.terms[ 0 ], k.terms[ 1 ])
	}

	out := "( "
	for _, t := range k.terms {
		out += t.String() + " v "
	}
	println( "slicing: ", out )
	out = out[ 0 : len( out ) - 3 ] + " )"
	return out
}

// http://vnsgu.ac.in/dept/publication/vnsgujst41july2015/25.pdf
func genKSAT( adj [][]bool )( []kClause, []kClause ){
	var kcs []kClause
	var kns []kClause

	for i := range adj {
		kc, kn := genKClause( adj, i )
		kcs = append( kcs, kc )
		kns = append( kns, kn )
	}

	return kcs, kns
}

type clause struct {
	terms	[ 3 ]term
}

func ( c clause ) String() string {
	return fmt.Sprintf( "( %s v %s v %s )", c.terms[ 0 ], c.terms[ 1 ], c.terms[ 2 ])
}

func genClause( a, b, c term ) clause {
	return clause{ [ 3 ]term{ a, b, c }}
}

func gen3SAT( kcs []kClause, kns []kClause )( []clause, int, int ){
	k := len( kns )
	ybase := k
	ys := 0

	var cs []clause
	yplus := 0
	for _, kc := range kcs {
		var next []clause
		next, yplus = gen3SATClause( kc, ybase )
		cs = append( cs, next... )

		ys += yplus
		ybase += yplus
	}
	for _, kn := range kns {
		var next []clause
		next, yplus = gen3SATClause( kn, ybase )
		cs = append( cs, next... )

		ys += yplus
		ybase += yplus
	}

	return cs, k, ys
}

func gen3SATClause( kc kClause, ybase int )( []clause, int ){
	k := len( kc.terms )

	if k == 0 {
		return nil, 0
	}

	if k == 1 {
		return []clause{ genClause( kc.terms[ 0 ], kc.terms[ 0 ], kc.terms[ 0 ])}, 0
	}

	if k == 2 {
		return []clause{ genClause( kc.terms[ 0 ], kc.terms[ 1 ], kc.terms[ 1 ])}, 0
	}

	if k == 3 {
		return []clause{ genClause( kc.terms[ 0 ], kc.terms[ 1 ], kc.terms[ 2 ])}, 0
	}

	var cs []clause

	i := 0
	cs = append( cs, genHeadClause( kc, ybase ))
	i++; i++

	for i < k - 2 {
		cs = append( cs, genMiddleClause( i, kc, ybase ))
		i++
	}

	cs = append( cs, genTailClause( i, kc, ybase ))

	return cs, k - 2
}

func genHeadClause( kc kClause, ybase int ) clause {
	y := term{
		negate:	true,
		label:	"y",
		idx:	ybase,
	}

	return genClause( kc.terms[ 0 ], kc.terms[ 1 ], y )
}

func genMiddleClause( i int, kc kClause, ybase int ) clause {
	ya := term{
		negate:	false,
		label:	"y",
		idx:	ybase + i - 2,
	}
	yb := term{
		negate:	true,
		label:	"y",
		idx:	ybase + i - 1,
	}

	fmt.Printf( "i: %d kc.terms: %d\n", i, len( kc.terms ))

	return genClause( kc.terms[ i ], ya, yb )
}

func genTailClause( i int, kc kClause, ybase int ) clause {
	y := term{
		negate:	false,
		label:	"y",
		idx:	ybase + i - 2,
	}

	return genClause( kc.terms[ i ], kc.terms[ i + 1 ], y )
}

func kSATcnf( kc []kClause, kn []kClause ) string {
	script := fmt.Sprintf( "p cnf %d %d\n", len( kc ), len( kc ) + len( kn ))

	cs := append( kc, kn... )

	for _, c := range cs {
		line := ""
		for _, t := range c.terms {
			if t.negate {
				line += "-"
			}

			line += strconv.Itoa( t.idx + 1 )
			line += " "		
		}

		line += "0\n"
		script += line
	}

	return script
}

func cnf( cs []clause, xs int, ys int ) string {
	script := fmt.Sprintf( "p cnf %d %d\n", xs + ys, len( cs ))

	for _, c := range cs {
		line := ""
		for _, t := range c.terms {
			if t.negate {
				line += "-"
			}

			line += strconv.Itoa( t.idx + 1 )
			line += " "		
		}

		line += "0\n"
		script += line
	}

	return script
}